# SPDX-License-Identifier: MIT
# Copyright (c) 2025-present, symseq Contributors

"""Topological entropy metrics."""

import numpy as np
from scipy.sparse.linalg import eigs

from symseq.utils.io import get_logger
from symseq.utils.strtools import chunk_transitions


logger = get_logger(__name__)


def topological_entropy(
    sequence: list | None = None,
    transitions: np.ndarray | None = None,
    max_lift: int = 15,
    method: str = "direct",
    verbose: bool = True,
) -> float | tuple:
    """
    Compute the topological entropy (TE) of a grammar using specified method.

    Parameters
    ----------
    sequence : list, optional
        Sequence required if using the "lift" method.
    transitions : np.ndarray, optional
        Binary transition table required if using the "direct" method.
    max_lift : int, default=15
        Maximum lift order for the "lift" method.
    method : str, default="lift"
        Method to compute TE: "lift" or "direct".
    verbose : bool, default=True
        Show progress information.

    Returns
    -------
    float or tuple
        For "direct" method: topological entropy value.
        For "lift" method: tuple of (lift, topological_entropy, TE_list).

    Raises
    ------
    AssertionError
        If method requirements are not met.
    ValueError
        If method is not "lift" or "direct".

    Notes
    -----
    Topological entropy h_top(G) measures the exponential growth rate of
    distinct strings that can be generated by grammar G:

    h_top(G) = lim_{n->inf} (1/n) * log2(|L_n(G)|)

    For known grammar with transition matrix T:
    h_top = log2(lambda_max(T))

    For observed sequences (lift method):
    Construct k-gram transition matrices M_k for increasing k until convergence.

    References
    ----------
    Bollt, E.M. & Jones, M.A. (2000). What is topological about topological
    entropy? Physica D, 139, 343-371.

    Shiff, L. & Katan, M. (2014). Topological entropy of bipartite graphs.
    European Journal of Combinatorics, 41, 272-283.
    """
    if verbose:
        logger.info(f"Computing topological entropy using the {method} method..")

    if method == "lift":
        assert sequence is not None, "The lift method requires a sequence"
        if len(sequence) <= 1000:
            logger.warning("Sequence is too short, entropy estimates may not be reliable.")

        TE = []
        lift, top_ent = 0, 0
        for lift in range(max_lift):
            M = chunk_transitions(sequence, lift + 1, verbose=False)
            evals_large, _ = eigs(M, 1, which="LM")
            max_eig = np.real(np.max(evals_large))

            TE.append(np.log(max_eig))
            if verbose:
                logger.info(f"Lift: {lift + 1}; Entropy: {TE[-1]}")

            # Early stopping: if TE is NaN or negative, stop
            if np.isnan(TE[-1]) or TE[-1] < 0:
                if verbose:
                    logger.info(f"TE became {'NaN' if np.isnan(TE[-1]) else 'negative'}, stopping at lift {lift}")
                # Use the last valid TE value
                if len(TE) > 1:
                    top_ent = TE[-2]
                    lift = lift  # Return the lift where it failed
                else:
                    top_ent = np.nan
                    lift = 0
                break

            if (len(TE) > 1) and (np.round(np.diff(TE), 1)[-1] == 0.0):
                top_ent = TE[-2]
                break
            else:
                top_ent = TE[-1]

            if np.isinf(top_ent):
                break

        return lift, top_ent, TE

    elif method == "direct":
        assert isinstance(transitions, np.ndarray), "Binary transition table is required for the direct method"
        assert np.array_equal(
            transitions, transitions.astype(bool)
        ), "The direct method requires a binary transition table"

        eigenvalues = np.linalg.eigvals(transitions)
        max_eig = np.real(np.max(eigenvalues))
        TE = np.log(max_eig)
        return TE

    else:
        raise ValueError(f"Unknown method {method}. Use 'lift' or 'direct'.")
